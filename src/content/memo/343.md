---
tags: []
status: release
ctime: 2025-01-01
mtime: 2025-01-01
---

이 글은 JavaScript의 `delete` 연산자에 대한 심도 있는 설명을 제공하며, 그 특정한 동작과 한계에 대해 강조하고 있습니다. 주요 내용을 요약하면 다음과 같습니다:

### `delete` 연산자의 목적

- `delete` 연산자는 **객체에서 속성 참조를 제거**하는 데 사용되며, 변수나 기본값(예: `0`)을 삭제하는 것은 아닙니다.
- 전역 또는 로컬 스코프에서 선언된 변수나 함수는 삭제되지 않으며, **객체 속성**에만 작동합니다.

### `delete`의 동작

1. **자신의 속성**:

   - 이 연산자는 객체의 **자신의 속성**에만 영향을 미칩니다. 만약 프로토타입 체인에 동일한 이름의 속성이 있다면, 이 속성은 삭제되지 않습니다. `delete`는 객체에 직접 속한 속성만 제거합니다.

2. **존재하지 않는 속성**:

   - 존재하지 않는 속성을 삭제하려고 해도, `delete`는 여전히 `true`를 반환합니다. 실제로 삭제할 것이 없더라도, 연산은 성공한 것으로 간주됩니다.

3. **설정 불가능한 속성**:

   - **설정 불가능한 속성**은 삭제할 수 없습니다. **비엄격 모드**에서는 이러한 속성을 삭제하려 하면 `false`를 반환하며, **엄격 모드**에서는 **TypeError**를 발생시킵니다.

4. **전역 스코프의 변수 및 함수**:

   - `var`, `let`, `const`로 선언된 변수나 함수 선언문으로 선언된 함수는 삭제할 수 없습니다. 이들은 전역 객체(예: `globalThis`)의 속성이며 설정 불가능합니다.
   - 예시:
     ```javascript
     delete object // false
     delete getName // false
     ```
     **비엄격 모드**에서는 `delete`가 `false`를 반환합니다. **엄격 모드**에서는 **SyntaxError**가 발생합니다.

5. **배열 요소**:

   - 배열의 요소를 삭제할 수는 있지만, 삭제해도 배열의 길이는 줄어들지 않습니다. 대신 삭제된 요소는 **빈 슬롯**으로 대체되며, 배열의 길이는 그대로 유지됩니다.
   - 예시:
     ```javascript
     let arr = [1, 2, 3]
     delete arr[1] // arr은 [1, <empty>, 3]이 됨
     ```

6. **메모리 관리**:
   - 객체의 속성이 삭제되고 그 속성의 값이 다른 객체였으며, 그 객체에 대한 남은 참조가 없다면, **JavaScript의 가비지 컬렉터**는 해당 객체가 차지한 메모리를 자동으로 해제합니다.

### 결론

- `delete` 연산자는 주로 **설정 가능한** 속성을 제거하는 데 사용해야 합니다.
- 설정 불가능한 속성이나 전역 변수를 다룰 때는 엄격 모드의 활성화 여부에 따라 다른 동작을 하기 때문에 주의가 필요합니다.
- 객체 참조를 삭제하면, 참조가 없어진 객체는 결국 가비지 컬렉터에 의해 메모리가 해제될 수 있습니다.

이 글에서는 `delete` 연산자를 사용할 때 주의를 기울일 것을 강조하며, 설정 가능한 속성을 제거해야 하는 경우에만 사용하는 것이 좋다고 제안합니다.
